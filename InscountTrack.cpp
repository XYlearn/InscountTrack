/*
 * Copyright (C) 2004-2021 Intel Corporation.
 * SPDX-License-Identifier: MIT
 */

#include "pin.H"
#include "types_base.PH"
#include "types_vmapi.PH"
#include <cstdio>
#include <cstring>
#include <fstream>
#include <iostream>

#include <sys/glibc-syscalls.h>
#include <sys/types.h>
#include <syscall.h>
#include <unistd.h>

using std::cerr;
using std::endl;
using std::ios;
using std::ofstream;
using std::string;

#ifndef ENABLE_SYSCALL_HOOK
#define ENABLE_SYSCALL_HOOK 1
#endif // !ENABLE_SYSCALL_HOOK

#ifndef ENABLE_LIBRARY_HOOK
#define ENABLE_LIBRARY_HOOK 1
#endif // !ENABLE_LIBRARY_HOOK

/* ================================================================== */
// Global variables
/* ================================================================== */

// track parent pid for fork
static pid_t parent_pid;

// The running count of instructions is kept here
// make it static to help the compiler optimize docount
static UINT64 icount = 0;

ofstream OutFile;

typedef struct {
  const char *name;
  bool found;
} TRTN;

typedef struct {
  const char *name;
} TSYS;

TRTN TRTNs[] = {
    {.name = "read"},     {.name = "fread"},   {.name = "recv"},
    {.name = "recvfrom"}, {.name = "recvmsg"},
};

TSYS TSYSs[0x200];

static const int TRTNCount = sizeof(TRTNs) / sizeof(TRTN);

/* ===================================================================== */
// Command line switches
/* ===================================================================== */

KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool", "o", "inscount.out",
                            "specify output file name");

/* ===================================================================== */
// Utilities
/* ===================================================================== */

INT32 Usage() {
  cerr << "This tool counts the number of dynamic instructions executed"
       << endl;
  cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
  return -1;
}

void track_count(const char *prefix, const char *hint) {
  OutFile << prefix << " " << icount << " : " << hint << endl;
}

/* ===================================================================== */
// Analysis routines
/* ===================================================================== */

// This function is called before every instruction is executed
VOID PIN_FAST_ANALYSIS_CALL docount(ADDRINT c) { icount += c; }

VOID BeforeFork(THREADID threadid, const CONTEXT *ctxt, VOID *arg) {
  parent_pid = PIN_GetPid();
}

VOID AfterForkInParent(THREADID threadid, const CONTEXT *ctxt, VOID *arg) {
  if (PIN_GetPid() != parent_pid)
    exit(-1);
}

VOID AfterForkInChild(THREADID threadid, const CONTEXT *ctxt, VOID *arg) {
  if ((PIN_GetPid() == parent_pid) || (getppid() != parent_pid))
    exit(-1);
  // We assume this fork is generated by fuzzing fork server
  icount = 0;
}

VOID SysBefore(ADDRINT ip, ADDRINT num, ADDRINT arg0, ADDRINT arg1,
               ADDRINT arg2, ADDRINT arg3, ADDRINT arg4, ADDRINT arg5) {
#if defined(TARGET_LINUX) && defined(TARGET_IA32)
  // On ia32 Linux, there are only 5 registers for passing system call
  // arguments, but mmap needs 6. For mmap on ia32, the first argument to the
  // system call is a pointer to an array of the 6 arguments
  if (num == SYS_mmap) {
    ADDRINT *mmapArgs = reinterpret_cast<ADDRINT *>(arg0);
    arg0 = mmapArgs[0];
    arg1 = mmapArgs[1];
    arg2 = mmapArgs[2];
    arg3 = mmapArgs[3];
    arg4 = mmapArgs[4];
    arg5 = mmapArgs[5];
  }
#endif

  // trace instruction count
  if (num == SYS_read || num == SYS_recvfrom || num == SYS_recvmmsg ||
      num == SYS_recvmsg) {
    // track by syscall
    track_count("[S]", TSYSs[num].name);
  }
}

// Print the return value of the system call
VOID SysAfter(ADDRINT ret) {}

VOID SyscallEntry(THREADID threadIndex, CONTEXT *ctxt, SYSCALL_STANDARD std,
                  VOID *v) {
  SysBefore(PIN_GetContextReg(ctxt, REG_INST_PTR),
            PIN_GetSyscallNumber(ctxt, std),
            PIN_GetSyscallArgument(ctxt, std, 0),
            PIN_GetSyscallArgument(ctxt, std, 1),
            PIN_GetSyscallArgument(ctxt, std, 2),
            PIN_GetSyscallArgument(ctxt, std, 3),
            PIN_GetSyscallArgument(ctxt, std, 4),
            PIN_GetSyscallArgument(ctxt, std, 5));
}

VOID SyscallExit(THREADID threadIndex, CONTEXT *ctxt, SYSCALL_STANDARD std,
                 VOID *v) {
  SysAfter(PIN_GetSyscallReturn(ctxt, std));
}

/* ===================================================================== */
// Instrumentation callbacks
/* ===================================================================== */

// Pin calls this function every time a new instruction is encountered
VOID Instruction(INS ins, VOID *v) {

  if (INS_IsSyscall(ins) && INS_IsValidForIpointAfter(ins)) {
    // Arguments and syscall number is only available before
    INS_InsertCall(ins, IPOINT_BEFORE, AFUNPTR(SysBefore), IARG_INST_PTR,
                   IARG_SYSCALL_NUMBER, IARG_SYSARG_VALUE, 0, IARG_SYSARG_VALUE,
                   1, IARG_SYSARG_VALUE, 2, IARG_SYSARG_VALUE, 3,
                   IARG_SYSARG_VALUE, 4, IARG_SYSARG_VALUE, 5, IARG_END);

    // return value only available after
    INS_InsertCall(ins, IPOINT_AFTER, AFUNPTR(SysAfter), IARG_SYSRET_VALUE,
                   IARG_END);
  }
}

VOID Trace(TRACE trace, VOID *v) {
  // Visit every basic block  in the trace
  for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl)) {
    // Insert a call to docount for every bbl, passing the number of
    // instructions. IPOINT_ANYWHERE allows Pin to schedule the call anywhere in
    // the bbl to obtain best performance. Use a fast linkage for the call.
    BBL_InsertCall(bbl, IPOINT_ANYWHERE, AFUNPTR(docount),
                   IARG_FAST_ANALYSIS_CALL, IARG_UINT32, BBL_NumIns(bbl),
                   IARG_END);
  }
}

VOID Image(IMG img, VOID *v) {

  for (int i = 0; i < TRTNCount; ++i) {
    TRTN *trtn = &TRTNs[i];
    if (trtn->found)
      continue;
    RTN rtn = RTN_FindByName(img, trtn->name);
    if (RTN_Valid(rtn)) {
      trtn->found = true;
      RTN_Open(rtn);
      RTN_InsertCall(rtn, IPOINT_BEFORE, AFUNPTR(track_count), IARG_ADDRINT,
                     "[L]", IARG_ADDRINT, trtn->name, IARG_END);
      RTN_Close(rtn);
    }
  }
}

// This function is called when the application exits
VOID Fini(INT32 code, VOID *v) {
  // track end
  track_count("[E]", "");
  OutFile << "----------------\n";
  OutFile.close();
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
/*   argc, argv are the entire command line: pin -t <toolname> -- ...    */
/* ===================================================================== */

void Init() {
  TSYSs[SYS_read] = {.name = "read"};
  TSYSs[SYS_recvfrom] = {.name = "recvfrom"};
  TSYSs[SYS_recvmmsg] = {.name = "recvmmsg"};
  TSYSs[SYS_recvmsg] = {.name = "recvmsg"};
}

int main(int argc, char *argv[]) {
  Init();
  // Initialize pin
  PIN_InitSymbols();
  if (PIN_Init(argc, argv))
    return Usage();

  OutFile.open(KnobOutputFile.Value().c_str(), ios::app);
  OutFile.setf(ios::showbase);

  // Register instrumentation callbacks

  // For calculating instruction count
  TRACE_AddInstrumentFunction(Trace, 0);

#if ENABLE_SYSCALL_HOOK
#if defined(TARGET_WINDOWS) | defined(TARGET_LINUX)
  // Register Syscall callbacks with supported API
  PIN_AddSyscallEntryFunction(SyscallEntry, 0);
  PIN_AddSyscallExitFunction(SyscallExit, 0);
#else // !(defined(TARGET_WINDOWS) | defined(TARGET_LINUX))
  // For O/S's (macOS*) that don't support PIN_AddSyscallEntryFunction(),
  // instrument the system call instruction.
  INS_AddInstrumentFunction(Instruction, 0);
#endif
#endif

#if ENABLE_LIBRARY_HOOK
  // Instrument library functions
  IMG_AddInstrumentFunction(Image, 0);
#endif

  // Register a notification handler that is called when the application
  // forks a new process.
  PIN_AddForkFunction(FPOINT_BEFORE, BeforeFork, 0);
  // PIN_AddForkFunction(FPOINT_AFTER_IN_PARENT, AfterForkInParent, 0);
  PIN_AddForkFunction(FPOINT_AFTER_IN_CHILD, AfterForkInChild, 0);

  // Register Fini to be called when the application exits
  PIN_AddFiniFunction(Fini, 0);

  // Start the program, never returns
  PIN_StartProgram();

  return 0;
}
